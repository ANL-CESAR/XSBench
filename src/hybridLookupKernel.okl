#if !OCCA_USING_CUDA
#  define __ldg(PTR) *(PTR)
#endif

typedef struct{
  double energy;
  double total_xs;
  double elastic_xs;
  double absorbtion_xs;
  double fission_xs;
  double nu_fission_xs;
} NuclideGridPoint;

typedef struct{
  double energy;
  int xs_ptrs;
} GridPoint;

const double dist[12] = {
  0.140,	// fuel
  0.052,	// cladding
  0.275,	// cold, borated water
  0.134,	// hot, borated water
  0.154,	// RPV
  0.064,	// Lower, radial reflector
  0.066,	// Upper reflector / top plate
  0.055,	// bottom plate
  0.008,	// bottom nozzle
  0.015,	// top nozzle
  0.025,	// top of fuel assemblies
  0.013 	// bottom of fuel assemblies
};

const double distSum[11] = {
  0.140,
  0.192,
  0.467,
  0.601,
  0.755,
  0.819,
  0.885,
  0.94,
  0.948,
  0.963,
  0.988
};

occaFunction double rn(unsigned long int * seed) {
  const unsigned long int a  = 16807;
  const unsigned long int m  = 2147483647;
  const unsigned long int n1 = ( a * (*seed) ) % m;

  *seed = n1;

  return ((double) n1 / m);
}

occaFunction long grid_search_kernel( const long int n,
                                      const double quarry,
                                      const GridPoint * const restrict A) {
  long int lowerLimit = 0;
  long int upperLimit = n-1;

  for(long int length = (upperLimit - lowerLimit); 1 < length; length /= 2){
    const long int examinationPoint = lowerLimit + ( length / 2 );

    if( A[examinationPoint].energy > quarry )
      upperLimit = examinationPoint;
    else
      lowerLimit = examinationPoint;
  }

  return lowerLimit;
}

occaFunction int pick_mat( unsigned long int * seed ) {
  // I have a nice spreadsheet supporting these numbers. They are
  // the fractions (by volume) of material in the core. Not a
  // *perfect* approximation of where XS lookups are going to occur,
  // but this will do a good job of biasing the system nonetheless.

  // Also could be argued that doing fractions by weight would be
  // a better approximation, but volume does a good enough job for now.

  //double roll = (double) rand() / (double) RAND_MAX;
  const double roll = rn(seed);

  // makes a pick based on the distro
  for( int i = 0; i < 11; i++ ){
    if(roll < distSum[i])
      return i;
  }

  return 11;
}

occaKernel void lookup_kernel(
    const int              * const restrict num_nucs,
    const GridPoint        * const restrict energy_grid,
    const int              * const restrict grid_ptrs,
    const NuclideGridPoint * const restrict nuclide_vector,
    const int              * const restrict mats,
    const int              * const restrict mats_idx,
    const double           * const restrict concs,
    const long int total_lookups,
    const long int n_isotopes,
    const long int n_gridpoints,
    double * restrict V_sums
    ) {

  for(int outer_id=0; outer_id<outer_dim; ++outer_id; outer0) {

    double inner_V_sum[5];

    for (int inner_id=0; inner_id<inner_dim; ++inner_id; inner0) {

      // Variables declared in the scope of an InnerFor loop are register variables
      const int global_id = outer_id*inner_dim + inner_id;
      unsigned long int seed = global_id*10000 + 1;

      inner_V_sum[0] = 0;
      inner_V_sum[1] = 0;
      inner_V_sum[2] = 0;
      inner_V_sum[3] = 0;
      inner_V_sum[4] = 0;

      if(global_id < total_lookups){
        // Randomly pick energy and material
        const double p_energy = rn(&seed);
        const int mat         = pick_mat(&seed);

        // Search for energy on energy grid
        const long int idx = grid_search_kernel(n_isotopes * n_gridpoints, p_energy, energy_grid);

        const int nucs_idx = __ldg(&num_nucs[mat]);
        const int mat_idx  = __ldg(&mats_idx[mat]);

        const int energy_xs_ptrs = energy_grid[idx].xs_ptrs;

        // For each nuclide in this material
        for(int j = 0; j < nucs_idx; j += 2) {

          //===== BEGIN: calculate micro xs
          double2 b[12];

          // Get this nuclide and its concentration
          const int nuc     = __ldg(&mats[mat_idx + j]);
          const double conc = __ldg(&concs[mat_idx + j]);

          // Get pointers to bounding values on nuclide energy grid
          const int grid_ptr = __ldg(&grid_ptrs[energy_xs_ptrs + nuc]);

          const double2 * const base = (double2*) (nuclide_vector +
                                                   (nuc * n_gridpoints) +
                                                   grid_ptr             -
                                                   (grid_ptr == (n_gridpoints - 1)));

          double conc2;
          const double2 * base2;

          const bool doTwoOps = (j < (nucs_idx - 1));

          if(doTwoOps){
            // Get this nuclide and its concentration
            const int nuc2 = __ldg(&mats[mat_idx + j + 1]);
            conc2          = __ldg(&concs[mat_idx + j + 1]);

            // Get pointers to bounding values on nuclide energy grid
            const int grid_ptr2 = __ldg(&grid_ptrs[energy_xs_ptrs + nuc2]);

            base2 = (double2*) (nuclide_vector +
                                (nuc2 * n_gridpoints) +
                                grid_ptr2             -
                                (grid_ptr2 == (n_gridpoints - 1)));
          }

          // Low
          b[0] = __ldg(base + 0);
          b[1] = __ldg(base + 1);
          b[2] = __ldg(base + 2);

          // High
          b[3] = __ldg(base + 3);
          b[4] = __ldg(base + 4);
          b[5] = __ldg(base + 5);

          if(doTwoOps){
            // Low
            b[6] = __ldg(base2 + 0);
            b[7] = __ldg(base2 + 1);
            b[8] = __ldg(base2 + 2);

            // High
            b[9]  = __ldg(base2 + 3);
            b[10] = __ldg(base2 + 4);
            b[11] = __ldg(base2 + 5);
          }

          const double f = (b[3].x - p_energy) / (b[3].x - b[0].x);

          // Interpolate micro xs for all interactions
          inner_V_sum[0] += conc * (b[3].y - f * (b[3].y - b[0].y));
          inner_V_sum[1] += conc * (b[4].x - f * (b[4].x - b[1].x));
          inner_V_sum[2] += conc * (b[4].y - f * (b[4].y - b[1].y));
          inner_V_sum[3] += conc * (b[5].x - f * (b[5].x - b[2].x));
          inner_V_sum[4] += conc * (b[5].y - f * (b[5].y - b[2].y));

          if(doTwoOps){
            const double f2 = (b[9].x - p_energy) / (b[9].x - b[6].x);

            // Interpolate micro xs for all interactions
            inner_V_sum[0] += conc2 * (b[9].y  - f2 * (b[9].y  - b[6].y));
            inner_V_sum[1] += conc2 * (b[10].x - f2 * (b[10].x - b[7].x));
            inner_V_sum[2] += conc2 * (b[10].y - f2 * (b[10].y - b[7].y));
            inner_V_sum[3] += conc2 * (b[11].x - f2 * (b[11].x - b[8].x));
            inner_V_sum[4] += conc2 * (b[11].y - f2 * (b[11].y - b[8].y));
          }
        } // materials loop

        V_sums[5*global_id + 0] = inner_V_sum[0];
        V_sums[5*global_id + 1] = inner_V_sum[1];
        V_sums[5*global_id + 2] = inner_V_sum[2];
        V_sums[5*global_id + 3] = inner_V_sum[3];
        V_sums[5*global_id + 4] = inner_V_sum[4];
      } // lookup loop
    } // inner 0

  } // outer0


}

occaKernel void lookup_touch(
    GridPoint * restrict energy_grid,
    int * grid_ptrs,
    NuclideGridPoint * restrict nuclide_vector,
    const long int n_isotopes,
    const long int n_gridpoints
    ) {

  for(int point = 0; point < n_gridpoints; ++point; outer0){
    for(int isotope = 0; isotope < n_isotopes; ++isotope; inner0){
      const int n_isotopes2 = (n_isotopes * n_isotopes);

      const int id  = ((point * n_isotopes)  + isotope);
      const int id2 = ((point * n_isotopes2) + (isotope * n_isotopes));

      energy_grid[id].energy  = 0.0;
      energy_grid[id].xs_ptrs = 0;

      nuclide_vector[id].energy        = 0.0;
      nuclide_vector[id].total_xs      = 0.0;
      nuclide_vector[id].elastic_xs    = 0.0;
      nuclide_vector[id].absorbtion_xs = 0.0;
      nuclide_vector[id].fission_xs    = 0.0;
      nuclide_vector[id].nu_fission_xs = 0.0;

      for(int i = 0; i < n_isotopes; ++i)
        grid_ptrs[id2 + i] = 0;
    }
  }
}
