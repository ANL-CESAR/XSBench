typedef struct{
  double energy;
  double total_xs;
  double elastic_xs;
  double absorbtion_xs;
  double fission_xs;
  double nu_fission_xs;
} NuclideGridPoint;

typedef struct{
  double energy;
  int xs_ptrs;
} GridPoint;

const double dist[12] = {
  0.140,	// fuel
  0.052,	// cladding
  0.275,	// cold, borated water
  0.134,	// hot, borated water
  0.154,	// RPV
  0.064,	// Lower, radial reflector
  0.066,	// Upper reflector / top plate
  0.055,	// bottom plate
  0.008,	// bottom nozzle
  0.015,	// top nozzle
  0.025,	// top of fuel assemblies
  0.013 	// bottom of fuel assemblies
};

const double distSum[11] = {
  0.140,
  0.192,
  0.467,
  0.601,
  0.755,
  0.819,
  0.885,
  0.94,
  0.948,
  0.963,
  0.988
};

occaFunction double rn(unsigned long int * seed) {
  const unsigned long int a  = 16807;
  const unsigned long int m  = 2147483647;
  const unsigned long int n1 = ( a * (*seed) ) % m;

  *seed = n1;

  return ((double) n1 / m);
}

occaFunction long grid_search_kernel( const long int n,
                                      const double quarry,
                                      const GridPoint * const restrict A) {
  long int lowerLimit = 0;
  long int upperLimit = n-1;

  for(long int length = (upperLimit - lowerLimit); 1 < length; length /= 2){
    const long int examinationPoint = lowerLimit + ( length / 2 );

    if( A[examinationPoint].energy > quarry )
      upperLimit = examinationPoint;
    else
      lowerLimit = examinationPoint;
  }

  return lowerLimit;
}

occaFunction int pick_mat( unsigned long int * seed ) {
  // I have a nice spreadsheet supporting these numbers. They are
  // the fractions (by volume) of material in the core. Not a
  // *perfect* approximation of where XS lookups are going to occur,
  // but this will do a good job of biasing the system nonetheless.

  // Also could be argued that doing fractions by weight would be
  // a better approximation, but volume does a good enough job for now.

  //double roll = (double) rand() / (double) RAND_MAX;
  const double roll = rn(seed);

  // makes a pick based on the distro
  for( int i = 0; i < 11; i++ ){
    if(roll < distSum[i])
      return i;
  }

  return 11;
}

occaKernel void lookup_kernel(
    const int              * const restrict num_nucs,
    const GridPoint        * const restrict energy_grid,
    const int              * const restrict grid_ptrs,
    const NuclideGridPoint * const restrict nuclide_vector,
    const int              * const restrict mats,
    const int              * const restrict mats_idx,
    const double           * const restrict concs,
    const long int total_lookups,
    const long int n_isotopes,
    const long int n_gridpoints,
    double            * restrict V_sums,
    unsigned long int * restrict L_sums
    ) {

  for(int outer_id=0; outer_id<outer_dim; ++outer_id; outer0) {

    // A cache per outer unit.  Each inner unit i writes to V_sums_cache[i]
    shared double            V_sums_cache[inner_dim];
    shared unsigned long int L_sums_cache[inner_dim];

    for (int inner_id=0; inner_id<inner_dim; ++inner_id; inner0) {

      // Variables declared in the scope of an InnerFor loop are register variables
      const int global_id = outer_id*inner_dim + inner_id;
      unsigned long int seed = global_id*10000 + 1;

      double            inner_V_sum = 0;
      unsigned long int inner_L_sum = 0;

      for (long int i=global_id; i < total_lookups; i += (outer_dim * inner_dim)) {

        // Randomly pick energy and material
        const double p_energy = rn(&seed);
        const int mat         = pick_mat(&seed);

        // Search for energy on energy grid
        const long int idx = grid_search_kernel(n_isotopes * n_gridpoints, p_energy, energy_grid);

        const int nucs_idx = num_nucs[mat];
        const int mat_idx  = mats_idx[mat];

        const int energy_xs_ptrs = energy_grid[idx].xs_ptrs;

        // For each nuclide in this material
        for( int j = 0; j < nucs_idx; j++ ) {

          //===== BEGIN: calculate micro xs

          // Get this nuclide and its concentration
          const int nuc     =  mats[mat_idx + j];
          const double conc = concs[mat_idx + j];

          // Get pointers to bounding values on nuclide energy grid
          const int grid_ptr = grid_ptrs[energy_xs_ptrs + nuc];

          const long int low_nuclide_idx = ((nuc * n_gridpoints) +
                                            grid_ptr             -
                                            (grid_ptr == (n_gridpoints - 1)));

          const NuclideGridPoint * const low  = (nuclide_vector + low_nuclide_idx + 0);
          const NuclideGridPoint * const high = (nuclide_vector + low_nuclide_idx + 1);

          // Interpolate micro xs for all interactions
          const double low_energy = low->energy;
          const double low_xs_sum = (low->total_xs      +
                                     low->elastic_xs    +
                                     low->absorbtion_xs +
                                     low->fission_xs    +
                                     low->nu_fission_xs);

          const double high_energy = high->energy;
          const double high_xs_sum = (high->total_xs      +
                                      high->elastic_xs    +
                                      high->absorbtion_xs +
                                      high->fission_xs    +
                                      high->nu_fission_xs);

          // Get interpolation factors
          const double f = (high_energy - p_energy) / (high_energy - low_energy);

          inner_V_sum += conc * (high_xs_sum - f * (high_xs_sum - low_xs_sum));

        } // materials loop

        // Accumulate verification sum
        inner_V_sum += (mat + p_energy);

        // Increment number of lookups
        ++inner_L_sum;

      } // lookup loop

      V_sums_cache[inner_id] = inner_V_sum;
      L_sums_cache[inner_id] = inner_L_sum;

    } //inner 0

    barrier(localMemFence);

    for (int i=inner_dim/2; i != 0; i /= 2) {
      for (int inner_id=0; inner_id<inner_dim; ++inner_id; inner0) {

        // Naive reduction
        if (inner_id < i && inner_id + i < inner_dim) {
          V_sums_cache[inner_id] += V_sums_cache[inner_id + i];
          L_sums_cache[inner_id] += L_sums_cache[inner_id + i];
        }
      }

      barrier(localMemFence);
    } //inner 0

    for (int inner_id=0; inner_id<inner_dim; ++inner_id; inner0) {
      if (inner_id == 0) {
        V_sums[outer_id] = V_sums_cache[0];
        L_sums[outer_id] = L_sums_cache[0];
      }
    } // inner 0

  } // outer0


}

occaKernel void lookup_touch(
    GridPoint * restrict energy_grid,
    int * grid_ptrs,
    NuclideGridPoint * restrict nuclide_vector,
    const long int n_isotopes,
    const long int n_gridpoints
    ) {

  for(int point = 0; point < n_gridpoints; ++point; outer0){
    for(int isotope = 0; isotope < n_isotopes; ++isotope; inner0){
      const int n_isotopes2 = (n_isotopes * n_isotopes);

      const int id  = ((point * n_isotopes)  + isotope);
      const int id2 = ((point * n_isotopes2) + (isotope * n_isotopes));

      energy_grid[id].energy  = 0.0;
      energy_grid[id].xs_ptrs = 0;

      nuclide_vector[id].energy        = 0.0;
      nuclide_vector[id].total_xs      = 0.0;
      nuclide_vector[id].elastic_xs    = 0.0;
      nuclide_vector[id].absorbtion_xs = 0.0;
      nuclide_vector[id].fission_xs    = 0.0;
      nuclide_vector[id].nu_fission_xs = 0.0;

      for(int i = 0; i < n_isotopes; ++i)
        grid_ptrs[id2 + i] = 0;
    }
  }
}
